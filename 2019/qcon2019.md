---
marp: true
theme: base
title: Parsing JSON Really Quickly
description: Presenting our work on simdjson
paginate: true
_paginate: false
---

![bg right 70%](simdjsonlogo.png)

---

## Parsing JSON Really Quickly : Lessons Learned
:rocket: :rocket: :rocket: :rocket: :rocket: :rocket: 


Daniel Lemire 
blog: https://lemire.me 
twitter: [@lemire](https://twitter.com/lemire)
GitHub: [https://github.com/lemire/](https://github.com/lemire/)

professor (Computer Science) at Université du Québec (TÉLUQ)
Montreal :canada: :cocktail: :beer:

---

## How fast can you read a large file?

- Are you limited by your disk or
- Are you limited by your CPU?

---
## An iMac disk: 2.2 GB/s

![](diskspeed.png)

[Faster SSDs (e.g., 5 GB/s) are available](https://www.anandtech.com/show/14960/team-group-joins-pcie-40-ssd-race-with-cardea-zero-z440-drives): PCIe 4.0, 5.0, 6.0... 

---
## Reading text lines (CPU only)

###~0.6 GB/s on 3.4 GHz Skylake 
in Java

```java
void parseLine(String s) {
  volume += s.length();
}

void readString(StringReader data) {				
  BufferedReader bf = new BufferedReader(data);
  bf.lines().forEach(s -> parseLine(s));
}
```

[Source available.](https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2019/07/26)
Improved by [JDK-8229022](https://bugs.openjdk.java.net/browse/JDK-8229022)


---
## Reading text lines (CPU only)

###~1.5 GB/s on 3.4 GHz Skylake 
in C++ (GNU GCC 8.3)

```C++
size_t sum_line_lengths(char * data, size_t length) {
   std::stringstream is;
   is.rdbuf()->pubsetbuf(data, length);
   std::string line;
   size_t sumofalllinelengths{0};

   while(getline(is, line)) {
     sumofalllinelengths += line.size();
   }

   return sumofalllinelengths;
}
```

[Source available.](https://github.com/lemire/simdjson/pull/344/files)


---

Even standard C++ `getline` cannot keep up with a fast disk while reading large files!

Need to uses multiple cores?

---

![](singlecoreperf.jpg)
[source](https://www.nextbigfuture.com/2019/02/the-end-of-moores-law-in-detail-and-starting-a-new-golden-age.html)

---

## JSON 

- Specified by Douglas Crockford 
- [RFC 7159](https://tools.ietf.org/html/rfc8259) by Tim Bray in 2013
- Ubiquitous format to exchange data

```javascript
{"Image": {"Width":  800,"Height": 600,
"Title":  "View from 15th Floor",
"Thumbnail": {
    "Url":    "http://www.example.com/81989943",
    "Height": 125,"Width":  100}
} 
```        

---

- "Our backend spends half its time serializing and deserializing json"

---


## JSON  parsing

- Read all of the content
- Check that it is valid JSON
- Check Unicode encoding
- Parse numbers
- Build DOM (document-object-model)

Harder than parsing lines?

---

## Jackson JSON speed (Java)

twitter.json: **0.350 GB/s** on  3.4 GHz Skylake

[Source code available.](https://github.com/lemire/jackson-json-bench)



|         | speed  |
| ------------- |:-------------:
| Jackson   (Java)  | 0.35 GB/s |
| readLines C++      | 1.5 GB/s |
| disk     |    2.2 GB/s |

---


## RapidJSON speed (C++)

twitter.json: **0.650 GB/s** on  3.4 GHz Skylake



|         | speed  |
| ------------- |:-------------:
| RapidJSON (C++)     | 0.650 GB/s |
| Jackson   (Java)  | 0.35 GB/s |
| readLines C++      | 1.5 GB/s |
| disk     |    2.2 GB/s |

---

## simdjson speed (C++)

twitter.json: **2.6 GB/s** on  3.4 GHz Skylake

|         | speed  |
| ------------- |:-------------:
| simdjson (C++)     | 2.6 GB/s |
| RapidJSON (C++)     | 0.650 GB/s |
| Jackson   (Java)  | 0.35 GB/s |
| readLines C++      | 1.5 GB/s |
| disk     |    2.2 GB/s |

---

2.6 GB/s on a 3.4 GHz (4 GHz turbo) processor is

~1.5 cycles per input byte


---

## Trick #1 : Use SIMD instructions

---

- Available on most commodity processors (ARM, x64)
- Originally added (Pentium) for multimedia (sound)
- Add wider (128-bit, 256-bit, 512-bit) words 
- Adds new fun instructions: do 32 table lookup at once.

---

## Trick #2 : avoids hard-to-predict branches

---

Write random numbers on an array.

```java
while (howmany != 0) {
    out[index] =  random();
    index += 1;
    howmany--;
}
```
e.g., ~ 3 cycles per iteration

---

Write only odd random numbers:

```java
while (howmany != 0) {
    val = random();
    if( val is odd) { // <=== new
      out[index] =  val;
      index += 1;
    }
    howmany--;
}
```

---

From 3 cycles to 15 cycles per value !

---

## Go branchless young man!

``` java
while (howmany != 0) {
    val = random();
    out[index] = val;
    index += (val bitand 1);
    howmany--;
}
````

back to under 4 cycles!

[Details and code available](https://lemire.me/blog/2019/10/15/mispredicted-branches-can-multiply-your-running-times/)

---

## What if I keep running the same benchmark?

(same pseudo-random integers from run-to-run)

![](mispredictions.png)


---

## Trick #3 : avoids memory/object allocation

---

In simdjson, the DOM (document-object-model) is stored into one contiguous tape.

---


## Trick #4 : measure the performance!



-  benchmark-driven development 

---

![](results.png)

---
## Continuous Integration tests 

- performance regression is a bug that should be spotted early

---

## Use precise measures

- time 
- instructions
- CPU cycles
- mispredicted branches
- data accesses

---

## Processor frequencies are not constant

- Especially on laptops
- CPU cycles different from time
- Time can be noisier than CPU cycles

---

## Use multiple systems

- x64
- ARM
- multiple microarchitectures

---

# Specific examples

---
## Example 1. UTF-8 

Strings are ASCII (1 byte per code point)

Otherwise multiple bytes (2, 3 or 4)

Only 1.1 M valid UTF-8 code points

---

## Validating UTF-8 with if/else/while

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>byte1 <span style='color:#808030; '>&lt;</span> <span style='color:#008000; '>0x80</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>return</span> true<span style='color:#800080; '>;</span> <span style='color:#696969; '>// ASCII</span>
<span style='color:#800080; '>}</span>
<span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>byte1 <span style='color:#808030; '>&lt;</span> <span style='color:#008000; '>0xE0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>byte1 <span style='color:#808030; '>&lt;</span> <span style='color:#008000; '>0xC2</span> <span style='color:#808030; '>|</span><span style='color:#808030; '>|</span> byte2 <span style='color:#808030; '>></span> <span style='color:#008000; '>0xBF</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>return</span> false<span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
<span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>byte1 <span style='color:#808030; '>&lt;</span> <span style='color:#008000; '>0xF0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// Three-byte form.</span>
      <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>byte2 <span style='color:#808030; '>></span> <span style='color:#008000; '>0xBF</span>
          <span style='color:#808030; '>|</span><span style='color:#808030; '>|</span> <span style='color:#808030; '>(</span>byte1 <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008000; '>0xE0</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> byte2 <span style='color:#808030; '>&lt;</span> <span style='color:#008000; '>0xA0</span><span style='color:#808030; '>)</span>
          <span style='color:#808030; '>|</span><span style='color:#808030; '>|</span> <span style='color:#808030; '>(</span>byte1 <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008000; '>0xED</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> <span style='color:#008000; '>0xA0</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>=</span> byte2<span style='color:#808030; '>)</span>
       blablabla
     <span style='color:#808030; '>)</span> blablabla
<span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// Four-byte form.</span>
      <span style='color:#808030; '>.</span><span style='color:#808030; '>.</span><span style='color:#808030; '>.</span><span style='color:#808030; '>.</span> blabla
<span style='color:#800080; '>}</span>

</pre>

---

## Using SIMD 

- Load 32-byte registers
- Use ~20 instructions
- No branch, no branch misprediction

---

## processing random UTF-8

|         |  cycles/char |
| ------------- |:-------------:
| conditions    | 11  |
| simdjson    | 0.5 |

20 x faster! [Source code available.](https://github.com/lemire/fastvalidate-utf-8)

## Example 2. Detecting Quotes


---

## Example 3. Classifying characters


histo

autobus

---

## Example 4. Number parsing is expensive

`strtod` : 

- 90 MB/s
- 38 cycles per byte
- 10 branch misses per floating-point number

---

Parse eight digits using three multiplications:

<pre style='color:#000000;background:#ffffff;'>uint64_t val<span style='color:#800080; '>;</span>
<span style='color:#603000; '>memcpy</span><span style='color:#808030; '>(</span><span style='color:#808030; '>&amp;</span>val<span style='color:#808030; '>,</span> chars<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>sizeof</span><span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
val <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>val <span style='color:#808030; '>&amp;</span> <span style='color:#008000; '>0x0F0F0F0F0F0F0F0F</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>*</span> <span style='color:#008c00; '>2561</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>8</span><span style='color:#800080; '>;</span>
val <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>val <span style='color:#808030; '>&amp;</span> <span style='color:#008000; '>0x00FF00FF00FF00FF</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>*</span> <span style='color:#008c00; '>6553601</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>16</span><span style='color:#800080; '>;</span>
val <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>val <span style='color:#808030; '>&amp;</span> <span style='color:#008000; '>0x0000FFFF0000FFFF</span><span style='color:#808030; '>)</span> 
       <span style='color:#808030; '>*</span> <span style='color:#008c00; '>42949672960001</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>32</span><span style='color:#800080; '>;</span>
</pre>
Can be vectorized (SIMD)


---

# Runtime dispatch


On first call, pointer checks CPU, and reassigns itself 

---



- Modern C++ 
- wrappers in Python, PHP, c#, Rust, JavaScript (node), Ruby
- ports to rust and c#

---

## Reference


- Geoff Langdale, Daniel Lemire, Parsing Gigabytes of JSON per Second,  VLDB Journal, https://arxiv.org/abs/1902.08318

- GitHub: [https://github.com/lemire/simdjson/](https://github.com/lemire/simdjson/)

---

## Credit


Geoff Langdale (algorithmic architect and wizard)

Contributors:

Thomas Navennec, Kai Wolf, Tyler Kennedy, Frank Wessels, George Fotopoulos, Heinz N. Gies, Emil Gedda, Wojciech Muła, Georgios Floros, Dong Xie, Nan Xiao, Egor Bogatov, Jinxi Wang, Luiz Fernando Peres, Wouter Bolsterlee, Anish Karandikar, Reini Urban. Tom Dyson, Ihor Dotsenko, Alexey Milovidov, Chang Liu, Sunny Gleason, John Keiser, Zach Bjornson, Vitaly Baranov, Juho Lauri, Michael Eisel, Io Daza Dillon, Paul Dreik, Jérémie Piotte and others

---
